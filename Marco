/*

    QUESTA PARTE COMMENTATA E' CIO' CHE E' RIMASTO DEL VECCHIO CODICE, E' ANCORA DA SISTEMARE
    FA DI NUOVO SEGMENTATION FAULT E IL PROBLEMA STA NELL'ULTIMO CICLO (VEDI COMMENTO SOTTO)

    int temp1, temp2;

    for (int k = 0; k < endpoints; ++k) {
        for (int i = 0; i < videos; ++i) {
            fscanf(input, "%d %d %d", &temp1, &temp2, &request_videos[temp2][temp1]);
        }
    }

    for(i=0; i<caches; i++) for(ii=0; ii<videos; ii++)
    {
        priority[i][ii] = 0;
        for(iii=0; iii<endpoints; iii++)
        {
            if(latency_to_cache[iii] > 0) priority[i][ii] += request_videos[iii][ii] * (latency[iii] - latency_to_cache[iii][i]) / (latency[iii] - 1.0);
        }
    }

    fclose(input);

}
*/

#include <stdio.h>
#include <stdlib.h>

int videos, endpoints, requests, caches, dimension;

int main(int argc, char *argv[]) {

    // CONTROLLO ARGOMENTI E APERTURA FILE

    if(argc != 2){
        printf("Wrong number of arguments");
        exit(1);
    }
    printf("Opening file...\n");
    FILE *input = fopen(argv[1], "r");
    if(input == NULL){
        printf("Failed opening file");
        exit(2);
    }
    printf("File opened correctly\n");

    // DICHIARAZIONE VARIABILI

    int i[3] = {};

    // DICHIARAZIONE ARRAY                                                                              #  ID           #  VALUE

    int sizes[videos];                                                                                  // video        size video
    int latency[endpoints];                                                                             // endpoint     latenza verso datacenter
    int number_of_caches[endpoints];                                                                    // endpoint     numero di caches connesse

    // DICHIARAZIONE MATRICI                                                                            #  ID_1         #  ID_2         #  VALUE

    int **latency_to_cache = (int**)malloc(endpoints*sizeof(int));                                      // endpoint     cache           latenza verso cache
    for(i[0]=0; i[0]<endpoints; i[0]++) latency_to_cache[i[0]]=(int*)malloc(caches*sizeof(int));        // 0 if NULL (no connection)

    int **request_videos = (int**)malloc(endpoints*sizeof(int));                                        // endpoint     videos          numero di richieste
    for(i[0]=0; i[0]<endpoints; i[0]++) request_videos[i[0]]=(int*)malloc(videos*sizeof(int));          // 0 if NULL (no requests)

    double **priority = (double**)malloc(caches*sizeof(double));                                        // cache        videos          priority
    for(i[0]=0; i[0]<caches; i[0]++) priority[i[0]]=(double*)malloc(videos*sizeof(double));             // 0 if NULL (no requests)

    // VIDEO SIZES

    for(i[0]=0; i[0]<videos; i[0]++) {
        fscanf(input, "%d", &sizes[i[0]]);
    }

    // CACHE CONNECTIONS

    for(i[0]=0; i[0]<endpoints; i[0]++) for(i[1]=0; i[1]<caches; i[1]++) latency_to_cache[i[0]][i[1]] = 0;

    // LATENCIES

    for(i[0]=0; i[0]<endpoints; i[0]++)
    {
        fscanf("%d %d", &latency[i[0]], &number_of_caches[i[0]]);
        int tmp_cache;
        for(i[1]=0; i[1]<number_of_caches[i[0]]; i[1]++) fscanf("%d %d", &tmp_cache, &latency_to_cache[i[0]][tmp_cache]);
    }

    // VIDEO REQUESTS
    // CI DEVE ESSERE QUALCOSA DI SBAGLIATO QUA
    // IL WHILE E' CORRETTO? MEGLIO UN FOR? QUEL EOF VA BENE? FORSE LA SEGMENTAZIONE E' DOVUTA AL PUNTATORE (input) ENORME

    int tmp_video;
    int tmp_endpoint;
    while(input!=EOF)
    {
        fscanf("%d %d %d", &tmp_video, &tmp_endpoint, &request_videos[tmp_endpoint][tmp_video]);
    }

    // CHIUSURA

    fclose(input);
    return 0;
}
